// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: span.proto

#ifndef PROTOBUF_INCLUDED_span_2eproto
#define PROTOBUF_INCLUDED_span_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_span_2eproto 

namespace protobuf_span_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_span_2eproto
namespace span {
class Annotation;
class AnnotationDefaultTypeInternal;
extern AnnotationDefaultTypeInternal _Annotation_default_instance_;
class AttachInfo;
class AttachInfoDefaultTypeInternal;
extern AttachInfoDefaultTypeInternal _AttachInfo_default_instance_;
class EndPoint;
class EndPointDefaultTypeInternal;
extern EndPointDefaultTypeInternal _EndPoint_default_instance_;
class Span;
class SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class TagEntry;
class TagEntryDefaultTypeInternal;
extern TagEntryDefaultTypeInternal _TagEntry_default_instance_;
}  // namespace span
namespace google {
namespace protobuf {
template<> ::span::Annotation* Arena::CreateMaybeMessage<::span::Annotation>(Arena*);
template<> ::span::AttachInfo* Arena::CreateMaybeMessage<::span::AttachInfo>(Arena*);
template<> ::span::EndPoint* Arena::CreateMaybeMessage<::span::EndPoint>(Arena*);
template<> ::span::Span* Arena::CreateMaybeMessage<::span::Span>(Arena*);
template<> ::span::TagEntry* Arena::CreateMaybeMessage<::span::TagEntry>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace span {

// ===================================================================

class Annotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:span.Annotation) */ {
 public:
  Annotation();
  virtual ~Annotation();

  Annotation(const Annotation& from);

  inline Annotation& operator=(const Annotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Annotation(Annotation&& from) noexcept
    : Annotation() {
    *this = ::std::move(from);
  }

  inline Annotation& operator=(Annotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Annotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Annotation* internal_default_instance() {
    return reinterpret_cast<const Annotation*>(
               &_Annotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Annotation* other);
  friend void swap(Annotation& a, Annotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Annotation* New() const final {
    return CreateMaybeMessage<Annotation>(NULL);
  }

  Annotation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Annotation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Annotation& from);
  void MergeFrom(const Annotation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Annotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required string event = 3;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 3;
  const ::std::string& event() const;
  void set_event(const ::std::string& value);
  #if LANG_CXX11
  void set_event(::std::string&& value);
  #endif
  void set_event(const char* value);
  void set_event(const char* value, size_t size);
  ::std::string* mutable_event();
  ::std::string* release_event();
  void set_allocated_event(::std::string* event);

  // optional string ex_name = 4;
  bool has_ex_name() const;
  void clear_ex_name();
  static const int kExNameFieldNumber = 4;
  const ::std::string& ex_name() const;
  void set_ex_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ex_name(::std::string&& value);
  #endif
  void set_ex_name(const char* value);
  void set_ex_name(const char* value, size_t size);
  ::std::string* mutable_ex_name();
  ::std::string* release_ex_name();
  void set_allocated_ex_name(::std::string* ex_name);

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:span.Annotation)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_event();
  void clear_has_event();
  void set_has_ex_name();
  void clear_has_ex_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr event_;
  ::google::protobuf::internal::ArenaStringPtr ex_name_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_span_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:span.EndPoint) */ {
 public:
  EndPoint();
  virtual ~EndPoint();

  EndPoint(const EndPoint& from);

  inline EndPoint& operator=(const EndPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndPoint(EndPoint&& from) noexcept
    : EndPoint() {
    *this = ::std::move(from);
  }

  inline EndPoint& operator=(EndPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndPoint* internal_default_instance() {
    return reinterpret_cast<const EndPoint*>(
               &_EndPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EndPoint* other);
  friend void swap(EndPoint& a, EndPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndPoint* New() const final {
    return CreateMaybeMessage<EndPoint>(NULL);
  }

  EndPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EndPoint& from);
  void MergeFrom(const EndPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sip = 1;
  bool has_sip() const;
  void clear_sip();
  static const int kSipFieldNumber = 1;
  const ::std::string& sip() const;
  void set_sip(const ::std::string& value);
  #if LANG_CXX11
  void set_sip(::std::string&& value);
  #endif
  void set_sip(const char* value);
  void set_sip(const char* value, size_t size);
  ::std::string* mutable_sip();
  ::std::string* release_sip();
  void set_allocated_sip(::std::string* sip);

  // required string dip = 3;
  bool has_dip() const;
  void clear_dip();
  static const int kDipFieldNumber = 3;
  const ::std::string& dip() const;
  void set_dip(const ::std::string& value);
  #if LANG_CXX11
  void set_dip(::std::string&& value);
  #endif
  void set_dip(const char* value);
  void set_dip(const char* value, size_t size);
  ::std::string* mutable_dip();
  ::std::string* release_dip();
  void set_allocated_dip(::std::string* dip);

  // optional int32 sport = 2;
  bool has_sport() const;
  void clear_sport();
  static const int kSportFieldNumber = 2;
  ::google::protobuf::int32 sport() const;
  void set_sport(::google::protobuf::int32 value);

  // optional int32 dport = 4;
  bool has_dport() const;
  void clear_dport();
  static const int kDportFieldNumber = 4;
  ::google::protobuf::int32 dport() const;
  void set_dport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:span.EndPoint)
 private:
  void set_has_sip();
  void clear_has_sip();
  void set_has_sport();
  void clear_has_sport();
  void set_has_dip();
  void clear_has_dip();
  void set_has_dport();
  void clear_has_dport();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sip_;
  ::google::protobuf::internal::ArenaStringPtr dip_;
  ::google::protobuf::int32 sport_;
  ::google::protobuf::int32 dport_;
  friend struct ::protobuf_span_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AttachInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:span.AttachInfo) */ {
 public:
  AttachInfo();
  virtual ~AttachInfo();

  AttachInfo(const AttachInfo& from);

  inline AttachInfo& operator=(const AttachInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttachInfo(AttachInfo&& from) noexcept
    : AttachInfo() {
    *this = ::std::move(from);
  }

  inline AttachInfo& operator=(AttachInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttachInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttachInfo* internal_default_instance() {
    return reinterpret_cast<const AttachInfo*>(
               &_AttachInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AttachInfo* other);
  friend void swap(AttachInfo& a, AttachInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttachInfo* New() const final {
    return CreateMaybeMessage<AttachInfo>(NULL);
  }

  AttachInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AttachInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AttachInfo& from);
  void MergeFrom(const AttachInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttachInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string app_name = 1;
  bool has_app_name() const;
  void clear_app_name();
  static const int kAppNameFieldNumber = 1;
  const ::std::string& app_name() const;
  void set_app_name(const ::std::string& value);
  #if LANG_CXX11
  void set_app_name(::std::string&& value);
  #endif
  void set_app_name(const char* value);
  void set_app_name(const char* value, size_t size);
  ::std::string* mutable_app_name();
  ::std::string* release_app_name();
  void set_allocated_app_name(::std::string* app_name);

  // optional string loc = 2;
  bool has_loc() const;
  void clear_loc();
  static const int kLocFieldNumber = 2;
  const ::std::string& loc() const;
  void set_loc(const ::std::string& value);
  #if LANG_CXX11
  void set_loc(::std::string&& value);
  #endif
  void set_loc(const char* value);
  void set_loc(const char* value, size_t size);
  ::std::string* mutable_loc();
  ::std::string* release_loc();
  void set_allocated_loc(::std::string* loc);

  // optional string env = 3;
  bool has_env() const;
  void clear_env();
  static const int kEnvFieldNumber = 3;
  const ::std::string& env() const;
  void set_env(const ::std::string& value);
  #if LANG_CXX11
  void set_env(::std::string&& value);
  #endif
  void set_env(const char* value);
  void set_env(const char* value, size_t size);
  ::std::string* mutable_env();
  ::std::string* release_env();
  void set_allocated_env(::std::string* env);

  // @@protoc_insertion_point(class_scope:span.AttachInfo)
 private:
  void set_has_app_name();
  void clear_has_app_name();
  void set_has_loc();
  void clear_has_loc();
  void set_has_env();
  void clear_has_env();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr app_name_;
  ::google::protobuf::internal::ArenaStringPtr loc_;
  ::google::protobuf::internal::ArenaStringPtr env_;
  friend struct ::protobuf_span_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TagEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:span.TagEntry) */ {
 public:
  TagEntry();
  virtual ~TagEntry();

  TagEntry(const TagEntry& from);

  inline TagEntry& operator=(const TagEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TagEntry(TagEntry&& from) noexcept
    : TagEntry() {
    *this = ::std::move(from);
  }

  inline TagEntry& operator=(TagEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TagEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TagEntry* internal_default_instance() {
    return reinterpret_cast<const TagEntry*>(
               &_TagEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TagEntry* other);
  friend void swap(TagEntry& a, TagEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TagEntry* New() const final {
    return CreateMaybeMessage<TagEntry>(NULL);
  }

  TagEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TagEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TagEntry& from);
  void MergeFrom(const TagEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string k = 1;
  bool has_k() const;
  void clear_k();
  static const int kKFieldNumber = 1;
  const ::std::string& k() const;
  void set_k(const ::std::string& value);
  #if LANG_CXX11
  void set_k(::std::string&& value);
  #endif
  void set_k(const char* value);
  void set_k(const char* value, size_t size);
  ::std::string* mutable_k();
  ::std::string* release_k();
  void set_allocated_k(::std::string* k);

  // optional string v = 2;
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 2;
  const ::std::string& v() const;
  void set_v(const ::std::string& value);
  #if LANG_CXX11
  void set_v(::std::string&& value);
  #endif
  void set_v(const char* value);
  void set_v(const char* value, size_t size);
  ::std::string* mutable_v();
  ::std::string* release_v();
  void set_allocated_v(::std::string* v);

  // @@protoc_insertion_point(class_scope:span.TagEntry)
 private:
  void set_has_k();
  void clear_has_k();
  void set_has_v();
  void clear_has_v();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr k_;
  ::google::protobuf::internal::ArenaStringPtr v_;
  friend struct ::protobuf_span_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Span : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:span.Span) */ {
 public:
  Span();
  virtual ~Span();

  Span(const Span& from);

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span(Span&& from) noexcept
    : Span() {
    *this = ::std::move(from);
  }

  inline Span& operator=(Span&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Span& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
               &_Span_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Span* other);
  friend void swap(Span& a, Span& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span* New() const final {
    return CreateMaybeMessage<Span>(NULL);
  }

  Span* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Span>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Span& from);
  void MergeFrom(const Span& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Span* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .span.Annotation annotations = 15;
  int annotations_size() const;
  void clear_annotations();
  static const int kAnnotationsFieldNumber = 15;
  ::span::Annotation* mutable_annotations(int index);
  ::google::protobuf::RepeatedPtrField< ::span::Annotation >*
      mutable_annotations();
  const ::span::Annotation& annotations(int index) const;
  ::span::Annotation* add_annotations();
  const ::google::protobuf::RepeatedPtrField< ::span::Annotation >&
      annotations() const;

  // repeated .span.TagEntry tags = 16;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 16;
  ::span::TagEntry* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::span::TagEntry >*
      mutable_tags();
  const ::span::TagEntry& tags(int index) const;
  ::span::TagEntry* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::span::TagEntry >&
      tags() const;

  // required string trace_id = 1;
  bool has_trace_id() const;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  const ::std::string& trace_id() const;
  void set_trace_id(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_id(::std::string&& value);
  #endif
  void set_trace_id(const char* value);
  void set_trace_id(const char* value, size_t size);
  ::std::string* mutable_trace_id();
  ::std::string* release_trace_id();
  void set_allocated_trace_id(::std::string* trace_id);

  // required string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string sdk_ver = 3;
  bool has_sdk_ver() const;
  void clear_sdk_ver();
  static const int kSdkVerFieldNumber = 3;
  const ::std::string& sdk_ver() const;
  void set_sdk_ver(const ::std::string& value);
  #if LANG_CXX11
  void set_sdk_ver(::std::string&& value);
  #endif
  void set_sdk_ver(const char* value);
  void set_sdk_ver(const char* value, size_t size);
  ::std::string* mutable_sdk_ver();
  ::std::string* release_sdk_ver();
  void set_allocated_sdk_ver(::std::string* sdk_ver);

  // required string type = 6;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required string component = 7;
  bool has_component() const;
  void clear_component();
  static const int kComponentFieldNumber = 7;
  const ::std::string& component() const;
  void set_component(const ::std::string& value);
  #if LANG_CXX11
  void set_component(::std::string&& value);
  #endif
  void set_component(const char* value);
  void set_component(const char* value, size_t size);
  ::std::string* mutable_component();
  ::std::string* release_component();
  void set_allocated_component(::std::string* component);

  // required string method_name = 8;
  bool has_method_name() const;
  void clear_method_name();
  static const int kMethodNameFieldNumber = 8;
  const ::std::string& method_name() const;
  void set_method_name(const ::std::string& value);
  #if LANG_CXX11
  void set_method_name(::std::string&& value);
  #endif
  void set_method_name(const char* value);
  void set_method_name(const char* value, size_t size);
  ::std::string* mutable_method_name();
  ::std::string* release_method_name();
  void set_allocated_method_name(::std::string* method_name);

  // optional string service_name = 9;
  bool has_service_name() const;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 9;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // optional string domain = 10;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 10;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional string sign = 11;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 11;
  const ::std::string& sign() const;
  void set_sign(const ::std::string& value);
  #if LANG_CXX11
  void set_sign(::std::string&& value);
  #endif
  void set_sign(const char* value);
  void set_sign(const char* value, size_t size);
  ::std::string* mutable_sign();
  ::std::string* release_sign();
  void set_allocated_sign(::std::string* sign);

  // required string status = 12;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 12;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // required .span.AttachInfo attachInfo = 14;
  bool has_attachinfo() const;
  void clear_attachinfo();
  static const int kAttachInfoFieldNumber = 14;
  private:
  const ::span::AttachInfo& _internal_attachinfo() const;
  public:
  const ::span::AttachInfo& attachinfo() const;
  ::span::AttachInfo* release_attachinfo();
  ::span::AttachInfo* mutable_attachinfo();
  void set_allocated_attachinfo(::span::AttachInfo* attachinfo);

  // required .span.EndPoint endpoint = 17;
  bool has_endpoint() const;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 17;
  private:
  const ::span::EndPoint& _internal_endpoint() const;
  public:
  const ::span::EndPoint& endpoint() const;
  ::span::EndPoint* release_endpoint();
  ::span::EndPoint* mutable_endpoint();
  void set_allocated_endpoint(::span::EndPoint* endpoint);

  // required int64 start = 4;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 4;
  ::google::protobuf::int64 start() const;
  void set_start(::google::protobuf::int64 value);

  // required int64 end = 5;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 5;
  ::google::protobuf::int64 end() const;
  void set_end(::google::protobuf::int64 value);

  // required int32 size = 13;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 13;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:span.Span)
 private:
  void set_has_trace_id();
  void clear_has_trace_id();
  void set_has_id();
  void clear_has_id();
  void set_has_sdk_ver();
  void clear_has_sdk_ver();
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();
  void set_has_type();
  void clear_has_type();
  void set_has_component();
  void clear_has_component();
  void set_has_method_name();
  void clear_has_method_name();
  void set_has_service_name();
  void clear_has_service_name();
  void set_has_domain();
  void clear_has_domain();
  void set_has_sign();
  void clear_has_sign();
  void set_has_status();
  void clear_has_status();
  void set_has_size();
  void clear_has_size();
  void set_has_attachinfo();
  void clear_has_attachinfo();
  void set_has_endpoint();
  void clear_has_endpoint();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::span::Annotation > annotations_;
  ::google::protobuf::RepeatedPtrField< ::span::TagEntry > tags_;
  ::google::protobuf::internal::ArenaStringPtr trace_id_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr sdk_ver_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr component_;
  ::google::protobuf::internal::ArenaStringPtr method_name_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr sign_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::span::AttachInfo* attachinfo_;
  ::span::EndPoint* endpoint_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 end_;
  ::google::protobuf::int32 size_;
  friend struct ::protobuf_span_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Annotation

// required string type = 1;
inline bool Annotation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Annotation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Annotation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Annotation::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Annotation::type() const {
  // @@protoc_insertion_point(field_get:span.Annotation.type)
  return type_.GetNoArena();
}
inline void Annotation::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Annotation.type)
}
#if LANG_CXX11
inline void Annotation::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Annotation.type)
}
#endif
inline void Annotation::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Annotation.type)
}
inline void Annotation::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Annotation.type)
}
inline ::std::string* Annotation::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:span.Annotation.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_type() {
  // @@protoc_insertion_point(field_release:span.Annotation.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:span.Annotation.type)
}

// required int64 timestamp = 2;
inline bool Annotation::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Annotation::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Annotation::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Annotation::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Annotation::timestamp() const {
  // @@protoc_insertion_point(field_get:span.Annotation.timestamp)
  return timestamp_;
}
inline void Annotation::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:span.Annotation.timestamp)
}

// required string event = 3;
inline bool Annotation::has_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Annotation::set_has_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Annotation::clear_has_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Annotation::clear_event() {
  event_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event();
}
inline const ::std::string& Annotation::event() const {
  // @@protoc_insertion_point(field_get:span.Annotation.event)
  return event_.GetNoArena();
}
inline void Annotation::set_event(const ::std::string& value) {
  set_has_event();
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Annotation.event)
}
#if LANG_CXX11
inline void Annotation::set_event(::std::string&& value) {
  set_has_event();
  event_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Annotation.event)
}
#endif
inline void Annotation::set_event(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_event();
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Annotation.event)
}
inline void Annotation::set_event(const char* value, size_t size) {
  set_has_event();
  event_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Annotation.event)
}
inline ::std::string* Annotation::mutable_event() {
  set_has_event();
  // @@protoc_insertion_point(field_mutable:span.Annotation.event)
  return event_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_event() {
  // @@protoc_insertion_point(field_release:span.Annotation.event)
  if (!has_event()) {
    return NULL;
  }
  clear_has_event();
  return event_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_event(::std::string* event) {
  if (event != NULL) {
    set_has_event();
  } else {
    clear_has_event();
  }
  event_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event);
  // @@protoc_insertion_point(field_set_allocated:span.Annotation.event)
}

// optional string ex_name = 4;
inline bool Annotation::has_ex_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Annotation::set_has_ex_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Annotation::clear_has_ex_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Annotation::clear_ex_name() {
  ex_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ex_name();
}
inline const ::std::string& Annotation::ex_name() const {
  // @@protoc_insertion_point(field_get:span.Annotation.ex_name)
  return ex_name_.GetNoArena();
}
inline void Annotation::set_ex_name(const ::std::string& value) {
  set_has_ex_name();
  ex_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Annotation.ex_name)
}
#if LANG_CXX11
inline void Annotation::set_ex_name(::std::string&& value) {
  set_has_ex_name();
  ex_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Annotation.ex_name)
}
#endif
inline void Annotation::set_ex_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ex_name();
  ex_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Annotation.ex_name)
}
inline void Annotation::set_ex_name(const char* value, size_t size) {
  set_has_ex_name();
  ex_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Annotation.ex_name)
}
inline ::std::string* Annotation::mutable_ex_name() {
  set_has_ex_name();
  // @@protoc_insertion_point(field_mutable:span.Annotation.ex_name)
  return ex_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Annotation::release_ex_name() {
  // @@protoc_insertion_point(field_release:span.Annotation.ex_name)
  if (!has_ex_name()) {
    return NULL;
  }
  clear_has_ex_name();
  return ex_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Annotation::set_allocated_ex_name(::std::string* ex_name) {
  if (ex_name != NULL) {
    set_has_ex_name();
  } else {
    clear_has_ex_name();
  }
  ex_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ex_name);
  // @@protoc_insertion_point(field_set_allocated:span.Annotation.ex_name)
}

// -------------------------------------------------------------------

// EndPoint

// required string sip = 1;
inline bool EndPoint::has_sip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndPoint::set_has_sip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndPoint::clear_has_sip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndPoint::clear_sip() {
  sip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sip();
}
inline const ::std::string& EndPoint::sip() const {
  // @@protoc_insertion_point(field_get:span.EndPoint.sip)
  return sip_.GetNoArena();
}
inline void EndPoint::set_sip(const ::std::string& value) {
  set_has_sip();
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.EndPoint.sip)
}
#if LANG_CXX11
inline void EndPoint::set_sip(::std::string&& value) {
  set_has_sip();
  sip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.EndPoint.sip)
}
#endif
inline void EndPoint::set_sip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sip();
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.EndPoint.sip)
}
inline void EndPoint::set_sip(const char* value, size_t size) {
  set_has_sip();
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.EndPoint.sip)
}
inline ::std::string* EndPoint::mutable_sip() {
  set_has_sip();
  // @@protoc_insertion_point(field_mutable:span.EndPoint.sip)
  return sip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EndPoint::release_sip() {
  // @@protoc_insertion_point(field_release:span.EndPoint.sip)
  if (!has_sip()) {
    return NULL;
  }
  clear_has_sip();
  return sip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EndPoint::set_allocated_sip(::std::string* sip) {
  if (sip != NULL) {
    set_has_sip();
  } else {
    clear_has_sip();
  }
  sip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sip);
  // @@protoc_insertion_point(field_set_allocated:span.EndPoint.sip)
}

// optional int32 sport = 2;
inline bool EndPoint::has_sport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndPoint::set_has_sport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndPoint::clear_has_sport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndPoint::clear_sport() {
  sport_ = 0;
  clear_has_sport();
}
inline ::google::protobuf::int32 EndPoint::sport() const {
  // @@protoc_insertion_point(field_get:span.EndPoint.sport)
  return sport_;
}
inline void EndPoint::set_sport(::google::protobuf::int32 value) {
  set_has_sport();
  sport_ = value;
  // @@protoc_insertion_point(field_set:span.EndPoint.sport)
}

// required string dip = 3;
inline bool EndPoint::has_dip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndPoint::set_has_dip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndPoint::clear_has_dip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndPoint::clear_dip() {
  dip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dip();
}
inline const ::std::string& EndPoint::dip() const {
  // @@protoc_insertion_point(field_get:span.EndPoint.dip)
  return dip_.GetNoArena();
}
inline void EndPoint::set_dip(const ::std::string& value) {
  set_has_dip();
  dip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.EndPoint.dip)
}
#if LANG_CXX11
inline void EndPoint::set_dip(::std::string&& value) {
  set_has_dip();
  dip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.EndPoint.dip)
}
#endif
inline void EndPoint::set_dip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dip();
  dip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.EndPoint.dip)
}
inline void EndPoint::set_dip(const char* value, size_t size) {
  set_has_dip();
  dip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.EndPoint.dip)
}
inline ::std::string* EndPoint::mutable_dip() {
  set_has_dip();
  // @@protoc_insertion_point(field_mutable:span.EndPoint.dip)
  return dip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EndPoint::release_dip() {
  // @@protoc_insertion_point(field_release:span.EndPoint.dip)
  if (!has_dip()) {
    return NULL;
  }
  clear_has_dip();
  return dip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EndPoint::set_allocated_dip(::std::string* dip) {
  if (dip != NULL) {
    set_has_dip();
  } else {
    clear_has_dip();
  }
  dip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dip);
  // @@protoc_insertion_point(field_set_allocated:span.EndPoint.dip)
}

// optional int32 dport = 4;
inline bool EndPoint::has_dport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndPoint::set_has_dport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndPoint::clear_has_dport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndPoint::clear_dport() {
  dport_ = 0;
  clear_has_dport();
}
inline ::google::protobuf::int32 EndPoint::dport() const {
  // @@protoc_insertion_point(field_get:span.EndPoint.dport)
  return dport_;
}
inline void EndPoint::set_dport(::google::protobuf::int32 value) {
  set_has_dport();
  dport_ = value;
  // @@protoc_insertion_point(field_set:span.EndPoint.dport)
}

// -------------------------------------------------------------------

// AttachInfo

// optional string app_name = 1;
inline bool AttachInfo::has_app_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachInfo::set_has_app_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachInfo::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachInfo::clear_app_name() {
  app_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_name();
}
inline const ::std::string& AttachInfo::app_name() const {
  // @@protoc_insertion_point(field_get:span.AttachInfo.app_name)
  return app_name_.GetNoArena();
}
inline void AttachInfo::set_app_name(const ::std::string& value) {
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.AttachInfo.app_name)
}
#if LANG_CXX11
inline void AttachInfo::set_app_name(::std::string&& value) {
  set_has_app_name();
  app_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.AttachInfo.app_name)
}
#endif
inline void AttachInfo::set_app_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.AttachInfo.app_name)
}
inline void AttachInfo::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.AttachInfo.app_name)
}
inline ::std::string* AttachInfo::mutable_app_name() {
  set_has_app_name();
  // @@protoc_insertion_point(field_mutable:span.AttachInfo.app_name)
  return app_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachInfo::release_app_name() {
  // @@protoc_insertion_point(field_release:span.AttachInfo.app_name)
  if (!has_app_name()) {
    return NULL;
  }
  clear_has_app_name();
  return app_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachInfo::set_allocated_app_name(::std::string* app_name) {
  if (app_name != NULL) {
    set_has_app_name();
  } else {
    clear_has_app_name();
  }
  app_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_name);
  // @@protoc_insertion_point(field_set_allocated:span.AttachInfo.app_name)
}

// optional string loc = 2;
inline bool AttachInfo::has_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttachInfo::set_has_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttachInfo::clear_has_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttachInfo::clear_loc() {
  loc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_loc();
}
inline const ::std::string& AttachInfo::loc() const {
  // @@protoc_insertion_point(field_get:span.AttachInfo.loc)
  return loc_.GetNoArena();
}
inline void AttachInfo::set_loc(const ::std::string& value) {
  set_has_loc();
  loc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.AttachInfo.loc)
}
#if LANG_CXX11
inline void AttachInfo::set_loc(::std::string&& value) {
  set_has_loc();
  loc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.AttachInfo.loc)
}
#endif
inline void AttachInfo::set_loc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_loc();
  loc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.AttachInfo.loc)
}
inline void AttachInfo::set_loc(const char* value, size_t size) {
  set_has_loc();
  loc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.AttachInfo.loc)
}
inline ::std::string* AttachInfo::mutable_loc() {
  set_has_loc();
  // @@protoc_insertion_point(field_mutable:span.AttachInfo.loc)
  return loc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachInfo::release_loc() {
  // @@protoc_insertion_point(field_release:span.AttachInfo.loc)
  if (!has_loc()) {
    return NULL;
  }
  clear_has_loc();
  return loc_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachInfo::set_allocated_loc(::std::string* loc) {
  if (loc != NULL) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
  loc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), loc);
  // @@protoc_insertion_point(field_set_allocated:span.AttachInfo.loc)
}

// optional string env = 3;
inline bool AttachInfo::has_env() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AttachInfo::set_has_env() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AttachInfo::clear_has_env() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AttachInfo::clear_env() {
  env_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_env();
}
inline const ::std::string& AttachInfo::env() const {
  // @@protoc_insertion_point(field_get:span.AttachInfo.env)
  return env_.GetNoArena();
}
inline void AttachInfo::set_env(const ::std::string& value) {
  set_has_env();
  env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.AttachInfo.env)
}
#if LANG_CXX11
inline void AttachInfo::set_env(::std::string&& value) {
  set_has_env();
  env_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.AttachInfo.env)
}
#endif
inline void AttachInfo::set_env(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_env();
  env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.AttachInfo.env)
}
inline void AttachInfo::set_env(const char* value, size_t size) {
  set_has_env();
  env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.AttachInfo.env)
}
inline ::std::string* AttachInfo::mutable_env() {
  set_has_env();
  // @@protoc_insertion_point(field_mutable:span.AttachInfo.env)
  return env_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachInfo::release_env() {
  // @@protoc_insertion_point(field_release:span.AttachInfo.env)
  if (!has_env()) {
    return NULL;
  }
  clear_has_env();
  return env_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachInfo::set_allocated_env(::std::string* env) {
  if (env != NULL) {
    set_has_env();
  } else {
    clear_has_env();
  }
  env_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), env);
  // @@protoc_insertion_point(field_set_allocated:span.AttachInfo.env)
}

// -------------------------------------------------------------------

// TagEntry

// required string k = 1;
inline bool TagEntry::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TagEntry::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TagEntry::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TagEntry::clear_k() {
  k_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_k();
}
inline const ::std::string& TagEntry::k() const {
  // @@protoc_insertion_point(field_get:span.TagEntry.k)
  return k_.GetNoArena();
}
inline void TagEntry::set_k(const ::std::string& value) {
  set_has_k();
  k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.TagEntry.k)
}
#if LANG_CXX11
inline void TagEntry::set_k(::std::string&& value) {
  set_has_k();
  k_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.TagEntry.k)
}
#endif
inline void TagEntry::set_k(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_k();
  k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.TagEntry.k)
}
inline void TagEntry::set_k(const char* value, size_t size) {
  set_has_k();
  k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.TagEntry.k)
}
inline ::std::string* TagEntry::mutable_k() {
  set_has_k();
  // @@protoc_insertion_point(field_mutable:span.TagEntry.k)
  return k_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TagEntry::release_k() {
  // @@protoc_insertion_point(field_release:span.TagEntry.k)
  if (!has_k()) {
    return NULL;
  }
  clear_has_k();
  return k_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TagEntry::set_allocated_k(::std::string* k) {
  if (k != NULL) {
    set_has_k();
  } else {
    clear_has_k();
  }
  k_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), k);
  // @@protoc_insertion_point(field_set_allocated:span.TagEntry.k)
}

// optional string v = 2;
inline bool TagEntry::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TagEntry::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TagEntry::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TagEntry::clear_v() {
  v_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_v();
}
inline const ::std::string& TagEntry::v() const {
  // @@protoc_insertion_point(field_get:span.TagEntry.v)
  return v_.GetNoArena();
}
inline void TagEntry::set_v(const ::std::string& value) {
  set_has_v();
  v_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.TagEntry.v)
}
#if LANG_CXX11
inline void TagEntry::set_v(::std::string&& value) {
  set_has_v();
  v_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.TagEntry.v)
}
#endif
inline void TagEntry::set_v(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_v();
  v_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.TagEntry.v)
}
inline void TagEntry::set_v(const char* value, size_t size) {
  set_has_v();
  v_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.TagEntry.v)
}
inline ::std::string* TagEntry::mutable_v() {
  set_has_v();
  // @@protoc_insertion_point(field_mutable:span.TagEntry.v)
  return v_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TagEntry::release_v() {
  // @@protoc_insertion_point(field_release:span.TagEntry.v)
  if (!has_v()) {
    return NULL;
  }
  clear_has_v();
  return v_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TagEntry::set_allocated_v(::std::string* v) {
  if (v != NULL) {
    set_has_v();
  } else {
    clear_has_v();
  }
  v_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), v);
  // @@protoc_insertion_point(field_set_allocated:span.TagEntry.v)
}

// -------------------------------------------------------------------

// Span

// required string trace_id = 1;
inline bool Span::has_trace_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Span::set_has_trace_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Span::clear_has_trace_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Span::clear_trace_id() {
  trace_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_id();
}
inline const ::std::string& Span::trace_id() const {
  // @@protoc_insertion_point(field_get:span.Span.trace_id)
  return trace_id_.GetNoArena();
}
inline void Span::set_trace_id(const ::std::string& value) {
  set_has_trace_id();
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.trace_id)
}
#if LANG_CXX11
inline void Span::set_trace_id(::std::string&& value) {
  set_has_trace_id();
  trace_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.trace_id)
}
#endif
inline void Span::set_trace_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_trace_id();
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.trace_id)
}
inline void Span::set_trace_id(const char* value, size_t size) {
  set_has_trace_id();
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.trace_id)
}
inline ::std::string* Span::mutable_trace_id() {
  set_has_trace_id();
  // @@protoc_insertion_point(field_mutable:span.Span.trace_id)
  return trace_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_trace_id() {
  // @@protoc_insertion_point(field_release:span.Span.trace_id)
  if (!has_trace_id()) {
    return NULL;
  }
  clear_has_trace_id();
  return trace_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_trace_id(::std::string* trace_id) {
  if (trace_id != NULL) {
    set_has_trace_id();
  } else {
    clear_has_trace_id();
  }
  trace_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_id);
  // @@protoc_insertion_point(field_set_allocated:span.Span.trace_id)
}

// required string id = 2;
inline bool Span::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Span::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Span::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Span::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Span::id() const {
  // @@protoc_insertion_point(field_get:span.Span.id)
  return id_.GetNoArena();
}
inline void Span::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.id)
}
#if LANG_CXX11
inline void Span::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.id)
}
#endif
inline void Span::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.id)
}
inline void Span::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.id)
}
inline ::std::string* Span::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:span.Span.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_id() {
  // @@protoc_insertion_point(field_release:span.Span.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:span.Span.id)
}

// required string sdk_ver = 3;
inline bool Span::has_sdk_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Span::set_has_sdk_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Span::clear_has_sdk_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Span::clear_sdk_ver() {
  sdk_ver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sdk_ver();
}
inline const ::std::string& Span::sdk_ver() const {
  // @@protoc_insertion_point(field_get:span.Span.sdk_ver)
  return sdk_ver_.GetNoArena();
}
inline void Span::set_sdk_ver(const ::std::string& value) {
  set_has_sdk_ver();
  sdk_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.sdk_ver)
}
#if LANG_CXX11
inline void Span::set_sdk_ver(::std::string&& value) {
  set_has_sdk_ver();
  sdk_ver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.sdk_ver)
}
#endif
inline void Span::set_sdk_ver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sdk_ver();
  sdk_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.sdk_ver)
}
inline void Span::set_sdk_ver(const char* value, size_t size) {
  set_has_sdk_ver();
  sdk_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.sdk_ver)
}
inline ::std::string* Span::mutable_sdk_ver() {
  set_has_sdk_ver();
  // @@protoc_insertion_point(field_mutable:span.Span.sdk_ver)
  return sdk_ver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_sdk_ver() {
  // @@protoc_insertion_point(field_release:span.Span.sdk_ver)
  if (!has_sdk_ver()) {
    return NULL;
  }
  clear_has_sdk_ver();
  return sdk_ver_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_sdk_ver(::std::string* sdk_ver) {
  if (sdk_ver != NULL) {
    set_has_sdk_ver();
  } else {
    clear_has_sdk_ver();
  }
  sdk_ver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdk_ver);
  // @@protoc_insertion_point(field_set_allocated:span.Span.sdk_ver)
}

// required int64 start = 4;
inline bool Span::has_start() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Span::set_has_start() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Span::clear_has_start() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Span::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 Span::start() const {
  // @@protoc_insertion_point(field_get:span.Span.start)
  return start_;
}
inline void Span::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:span.Span.start)
}

// required int64 end = 5;
inline bool Span::has_end() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Span::set_has_end() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Span::clear_has_end() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Span::clear_end() {
  end_ = GOOGLE_LONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::int64 Span::end() const {
  // @@protoc_insertion_point(field_get:span.Span.end)
  return end_;
}
inline void Span::set_end(::google::protobuf::int64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:span.Span.end)
}

// required string type = 6;
inline bool Span::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Span::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Span::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Span::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Span::type() const {
  // @@protoc_insertion_point(field_get:span.Span.type)
  return type_.GetNoArena();
}
inline void Span::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.type)
}
#if LANG_CXX11
inline void Span::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.type)
}
#endif
inline void Span::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.type)
}
inline void Span::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.type)
}
inline ::std::string* Span::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:span.Span.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_type() {
  // @@protoc_insertion_point(field_release:span.Span.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:span.Span.type)
}

// required string component = 7;
inline bool Span::has_component() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Span::set_has_component() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Span::clear_has_component() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Span::clear_component() {
  component_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_component();
}
inline const ::std::string& Span::component() const {
  // @@protoc_insertion_point(field_get:span.Span.component)
  return component_.GetNoArena();
}
inline void Span::set_component(const ::std::string& value) {
  set_has_component();
  component_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.component)
}
#if LANG_CXX11
inline void Span::set_component(::std::string&& value) {
  set_has_component();
  component_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.component)
}
#endif
inline void Span::set_component(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_component();
  component_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.component)
}
inline void Span::set_component(const char* value, size_t size) {
  set_has_component();
  component_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.component)
}
inline ::std::string* Span::mutable_component() {
  set_has_component();
  // @@protoc_insertion_point(field_mutable:span.Span.component)
  return component_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_component() {
  // @@protoc_insertion_point(field_release:span.Span.component)
  if (!has_component()) {
    return NULL;
  }
  clear_has_component();
  return component_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_component(::std::string* component) {
  if (component != NULL) {
    set_has_component();
  } else {
    clear_has_component();
  }
  component_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), component);
  // @@protoc_insertion_point(field_set_allocated:span.Span.component)
}

// required string method_name = 8;
inline bool Span::has_method_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Span::set_has_method_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Span::clear_has_method_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Span::clear_method_name() {
  method_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_method_name();
}
inline const ::std::string& Span::method_name() const {
  // @@protoc_insertion_point(field_get:span.Span.method_name)
  return method_name_.GetNoArena();
}
inline void Span::set_method_name(const ::std::string& value) {
  set_has_method_name();
  method_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.method_name)
}
#if LANG_CXX11
inline void Span::set_method_name(::std::string&& value) {
  set_has_method_name();
  method_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.method_name)
}
#endif
inline void Span::set_method_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_method_name();
  method_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.method_name)
}
inline void Span::set_method_name(const char* value, size_t size) {
  set_has_method_name();
  method_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.method_name)
}
inline ::std::string* Span::mutable_method_name() {
  set_has_method_name();
  // @@protoc_insertion_point(field_mutable:span.Span.method_name)
  return method_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_method_name() {
  // @@protoc_insertion_point(field_release:span.Span.method_name)
  if (!has_method_name()) {
    return NULL;
  }
  clear_has_method_name();
  return method_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_method_name(::std::string* method_name) {
  if (method_name != NULL) {
    set_has_method_name();
  } else {
    clear_has_method_name();
  }
  method_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method_name);
  // @@protoc_insertion_point(field_set_allocated:span.Span.method_name)
}

// optional string service_name = 9;
inline bool Span::has_service_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Span::set_has_service_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Span::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Span::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
inline const ::std::string& Span::service_name() const {
  // @@protoc_insertion_point(field_get:span.Span.service_name)
  return service_name_.GetNoArena();
}
inline void Span::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.service_name)
}
#if LANG_CXX11
inline void Span::set_service_name(::std::string&& value) {
  set_has_service_name();
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.service_name)
}
#endif
inline void Span::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.service_name)
}
inline void Span::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.service_name)
}
inline ::std::string* Span::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:span.Span.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_service_name() {
  // @@protoc_insertion_point(field_release:span.Span.service_name)
  if (!has_service_name()) {
    return NULL;
  }
  clear_has_service_name();
  return service_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:span.Span.service_name)
}

// optional string domain = 10;
inline bool Span::has_domain() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Span::set_has_domain() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Span::clear_has_domain() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Span::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_domain();
}
inline const ::std::string& Span::domain() const {
  // @@protoc_insertion_point(field_get:span.Span.domain)
  return domain_.GetNoArena();
}
inline void Span::set_domain(const ::std::string& value) {
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.domain)
}
#if LANG_CXX11
inline void Span::set_domain(::std::string&& value) {
  set_has_domain();
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.domain)
}
#endif
inline void Span::set_domain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.domain)
}
inline void Span::set_domain(const char* value, size_t size) {
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.domain)
}
inline ::std::string* Span::mutable_domain() {
  set_has_domain();
  // @@protoc_insertion_point(field_mutable:span.Span.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_domain() {
  // @@protoc_insertion_point(field_release:span.Span.domain)
  if (!has_domain()) {
    return NULL;
  }
  clear_has_domain();
  return domain_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    set_has_domain();
  } else {
    clear_has_domain();
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:span.Span.domain)
}

// optional string sign = 11;
inline bool Span::has_sign() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Span::set_has_sign() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Span::clear_has_sign() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Span::clear_sign() {
  sign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign();
}
inline const ::std::string& Span::sign() const {
  // @@protoc_insertion_point(field_get:span.Span.sign)
  return sign_.GetNoArena();
}
inline void Span::set_sign(const ::std::string& value) {
  set_has_sign();
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.sign)
}
#if LANG_CXX11
inline void Span::set_sign(::std::string&& value) {
  set_has_sign();
  sign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.sign)
}
#endif
inline void Span::set_sign(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign();
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.sign)
}
inline void Span::set_sign(const char* value, size_t size) {
  set_has_sign();
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.sign)
}
inline ::std::string* Span::mutable_sign() {
  set_has_sign();
  // @@protoc_insertion_point(field_mutable:span.Span.sign)
  return sign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_sign() {
  // @@protoc_insertion_point(field_release:span.Span.sign)
  if (!has_sign()) {
    return NULL;
  }
  clear_has_sign();
  return sign_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_sign(::std::string* sign) {
  if (sign != NULL) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
  sign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign);
  // @@protoc_insertion_point(field_set_allocated:span.Span.sign)
}

// required string status = 12;
inline bool Span::has_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Span::set_has_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Span::clear_has_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Span::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& Span::status() const {
  // @@protoc_insertion_point(field_get:span.Span.status)
  return status_.GetNoArena();
}
inline void Span::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:span.Span.status)
}
#if LANG_CXX11
inline void Span::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:span.Span.status)
}
#endif
inline void Span::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:span.Span.status)
}
inline void Span::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:span.Span.status)
}
inline ::std::string* Span::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:span.Span.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_status() {
  // @@protoc_insertion_point(field_release:span.Span.status)
  if (!has_status()) {
    return NULL;
  }
  clear_has_status();
  return status_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:span.Span.status)
}

// required int32 size = 13;
inline bool Span::has_size() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Span::set_has_size() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Span::clear_has_size() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Span::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Span::size() const {
  // @@protoc_insertion_point(field_get:span.Span.size)
  return size_;
}
inline void Span::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:span.Span.size)
}

// required .span.AttachInfo attachInfo = 14;
inline bool Span::has_attachinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Span::set_has_attachinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Span::clear_has_attachinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Span::clear_attachinfo() {
  if (attachinfo_ != NULL) attachinfo_->Clear();
  clear_has_attachinfo();
}
inline const ::span::AttachInfo& Span::_internal_attachinfo() const {
  return *attachinfo_;
}
inline const ::span::AttachInfo& Span::attachinfo() const {
  const ::span::AttachInfo* p = attachinfo_;
  // @@protoc_insertion_point(field_get:span.Span.attachInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::span::AttachInfo*>(
      &::span::_AttachInfo_default_instance_);
}
inline ::span::AttachInfo* Span::release_attachinfo() {
  // @@protoc_insertion_point(field_release:span.Span.attachInfo)
  clear_has_attachinfo();
  ::span::AttachInfo* temp = attachinfo_;
  attachinfo_ = NULL;
  return temp;
}
inline ::span::AttachInfo* Span::mutable_attachinfo() {
  set_has_attachinfo();
  if (attachinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::span::AttachInfo>(GetArenaNoVirtual());
    attachinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:span.Span.attachInfo)
  return attachinfo_;
}
inline void Span::set_allocated_attachinfo(::span::AttachInfo* attachinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attachinfo_;
  }
  if (attachinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attachinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attachinfo, submessage_arena);
    }
    set_has_attachinfo();
  } else {
    clear_has_attachinfo();
  }
  attachinfo_ = attachinfo;
  // @@protoc_insertion_point(field_set_allocated:span.Span.attachInfo)
}

// repeated .span.Annotation annotations = 15;
inline int Span::annotations_size() const {
  return annotations_.size();
}
inline void Span::clear_annotations() {
  annotations_.Clear();
}
inline ::span::Annotation* Span::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:span.Span.annotations)
  return annotations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::span::Annotation >*
Span::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:span.Span.annotations)
  return &annotations_;
}
inline const ::span::Annotation& Span::annotations(int index) const {
  // @@protoc_insertion_point(field_get:span.Span.annotations)
  return annotations_.Get(index);
}
inline ::span::Annotation* Span::add_annotations() {
  // @@protoc_insertion_point(field_add:span.Span.annotations)
  return annotations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::span::Annotation >&
Span::annotations() const {
  // @@protoc_insertion_point(field_list:span.Span.annotations)
  return annotations_;
}

// repeated .span.TagEntry tags = 16;
inline int Span::tags_size() const {
  return tags_.size();
}
inline void Span::clear_tags() {
  tags_.Clear();
}
inline ::span::TagEntry* Span::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:span.Span.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::span::TagEntry >*
Span::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:span.Span.tags)
  return &tags_;
}
inline const ::span::TagEntry& Span::tags(int index) const {
  // @@protoc_insertion_point(field_get:span.Span.tags)
  return tags_.Get(index);
}
inline ::span::TagEntry* Span::add_tags() {
  // @@protoc_insertion_point(field_add:span.Span.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::span::TagEntry >&
Span::tags() const {
  // @@protoc_insertion_point(field_list:span.Span.tags)
  return tags_;
}

// required .span.EndPoint endpoint = 17;
inline bool Span::has_endpoint() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Span::set_has_endpoint() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Span::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Span::clear_endpoint() {
  if (endpoint_ != NULL) endpoint_->Clear();
  clear_has_endpoint();
}
inline const ::span::EndPoint& Span::_internal_endpoint() const {
  return *endpoint_;
}
inline const ::span::EndPoint& Span::endpoint() const {
  const ::span::EndPoint* p = endpoint_;
  // @@protoc_insertion_point(field_get:span.Span.endpoint)
  return p != NULL ? *p : *reinterpret_cast<const ::span::EndPoint*>(
      &::span::_EndPoint_default_instance_);
}
inline ::span::EndPoint* Span::release_endpoint() {
  // @@protoc_insertion_point(field_release:span.Span.endpoint)
  clear_has_endpoint();
  ::span::EndPoint* temp = endpoint_;
  endpoint_ = NULL;
  return temp;
}
inline ::span::EndPoint* Span::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == NULL) {
    auto* p = CreateMaybeMessage<::span::EndPoint>(GetArenaNoVirtual());
    endpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:span.Span.endpoint)
  return endpoint_;
}
inline void Span::set_allocated_endpoint(::span::EndPoint* endpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete endpoint_;
  }
  if (endpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      endpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
  endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:span.Span.endpoint)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace span

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_span_2eproto
